# -*- coding: utf-8 -*-
"""
This module provides the `AutomatedPullRequestGenerator` class, which automates the process of generating pull request titles and descriptions 
based on code diffs. It interacts with external APIs and manages file operations to fetch, process, and save pull request data.

Classes:
    - AutomatedPullRequestGenerator: Automates the generation of pull request titles and descriptions.

Usage:
    Instantiate the `AutomatedPullRequestGenerator` class and call its methods to process pull request samples.
"""

import sys
import os
import logging
import time
from typing import Optional
import requests

# add the parent directory of 'utils' to the Python path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.client.openUiClient import OpenUiClient
from src.client.gitHubClient import GitHubClient, PullRequestState
from src.codeSamples.codeSamplesFetcher import CodeSamplesFetcher
from utils.fileManager import FileManager

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

class AutomatedPullRequestGenerator:
    """
    A class to automate the generation of pull request titles and descriptions.

    Attributes:
        folderPath (str): The path to the folder where code samples are stored.
    """

    folderPath = r'c:\Users\vicme\OneDrive\Livros Unicamp\TCC\Implementacao\AutomatedPullRequestGenerator\data\downloadedCodeSamples'

    def __init__(self):
        """
        Initializes the `AutomatedPullRequestGenerator` class by setting up clients and utilities.
        """
        self.openUiClient = OpenUiClient()
        self.gitHubClient = GitHubClient()
        self.codeSamplesFetcher = CodeSamplesFetcher()
        self.fileManager = FileManager()

    def runAutomatedPullRequestGenerator(self, numberOfSamples: int = 0, model: str = 'llama3.1:8b') -> None:
        """
        Main method to run the Automated Pull Request Generator.

        Args:
            numberOfSamples (int): The number of diff files to process.
        """
        logging.info(f"Starting Automated Pull Request Generator for {numberOfSamples} diffFiles using model: {model}...")
        
        filesMap = self.getPRsDiffFilesAndDescriptionSamplesAsMap()
        fileSamples = list(filesMap.keys())
        totalFiles = len(fileSamples)
        logging.debug(f"Number of files to process: {totalFiles}")

        if numberOfSamples == 0:
            numberOfSamples = totalFiles
            logging.info(f"No specific number of samples provided. Processing all {numberOfSamples} files.")

        processed = 0
        for file in fileSamples[:numberOfSamples]:
            logging.info(f"Processing file: {file}")
            filePath = os.path.join(self.folderPath, file)
            response = self.generatePullRequestTitleAndDescription(filePath, model=model)

            processed += 1
            percent = (processed / numberOfSamples) * 100
            bar_length = 40
            filled_length = int(bar_length * processed // numberOfSamples)
            bar = '█' * filled_length + '-' * (bar_length - filled_length)
            print()
            print(f"\rProgress running for model {model}: |{bar}| {percent:.2f}%", end='', flush=True)
            print()
            if response:
                prContent = self._sanitizeResponse(self._getMessageFromLLMResponse(response))

                fileName = f"{os.path.splitext(file)[0]}_title_body_AutoGenerated_{self._sanitizedModelName(model)}{os.path.splitext(file)[1]}"
                fileName = self.fileManager.createFile(self.folderPath, fileName)
                filePath = os.path.join(self.folderPath, fileName)
                self.fileManager.saveToFile("", filePath)
                self.fileManager.saveToFile(prContent, filePath)
            else:
                logging.error(f"Failed to generate PR title and body for {file}.")

        logging.info("Automated Pull Request Generator completed successfully.")
    
    def runAutomatedPullRequestGeneratorForAllModels(self, numberOfSamples: int = 0) -> None:
        """
        Runs generatePullRequestTitleAndDescription for each file for all available models.

        Args:
            numberOfSamples (int): The number of diff files to process. If 0, processes all available files.
        """
        logging.info("Starting Automated Pull Request Generator for all models...")
        filesMap = self.getPRsDiffFilesAndDescriptionSamplesAsMap()
        fileSamples = list(filesMap.keys()) # [5754:]  # Skip the first files # TODO create a funtion to filter out already created PRs for a specific model
        
        totalFiles = len(fileSamples)

        # openUiClient = OpenUiClient()
        # models = openUiClient.getAvailableApiModels()[8:]
        
        # run for all samples
        models = ['deepseek-r1:14b','llama3:8b', 'qwen:1.8b', 'phi:latest','stable-code:latest', 'gemma3:12b', 'phi4-reasoning:latest', 'llama3.2-vision:11b']     
        # models = ['llama3.1:8b']
        
        if not models:
            logging.error("No models available from API.")
            return

        if numberOfSamples == 0:
            numberOfSamples = totalFiles
            logging.info(f"No specific number of samples provided. Processing all {numberOfSamples} files.")

        totalRuns = len(models) * numberOfSamples
        count = 0

        mean_time = 0
        time_accumulator = 0
        update_interval = 10
        for file in fileSamples[:numberOfSamples]:
            sleep_time = 0.2  # Sleep time to avoid hitting API rate limits
            time.sleep(sleep_time)  # Sleep for a short duration to avoid hitting API rate limits
            for model in models:
                count += 1
                if self.fileManager.searchFiles(self.folderPath, f"{os.path.splitext(file)[0]}_title_body_AutoGenerated_{self._sanitizedModelName(model)}{os.path.splitext(file)[1]}") is None:
                    step_start_time = time.time()
                    percent = (count / totalRuns) * 100
                    bar_length = 40
                    filled_length = int(bar_length * count // totalRuns)
                    bar = '█' * filled_length + '-' * (bar_length - filled_length)
                    print()
                    print(f"Total files processed ({count}/{totalRuns})")
                    print(f"\rProgress: |{bar}| {percent:.2f}% - File: {file} - Model: {model}", end='', flush=True)
                    print()
                    filePath = os.path.join(self.folderPath, file)
                    response = self.generatePullRequestTitleAndDescription(filePath, model=model)
                    step_end_time = time.time()
                    step_duration = step_end_time - step_start_time
                    time_accumulator += step_duration

                    # Update mean time every 10 executions
                    if count % update_interval == 0 or count == 1:
                        mean_time = time_accumulator / (count if count < update_interval else update_interval)
                        time_accumulator = 0

                    # Estimate remaining time
                    remaining = totalRuns - count
                    estimated_rest = mean_time * remaining
                    hours = int(estimated_rest // 3600)
                    minutes = int((estimated_rest % 3600) // 60)
                    print()
                    print(f"Time spent for this step: {step_duration:.2f} seconds")
                    print(f"Estimated resting time: {hours}h {minutes}m")

                    if response:
                        prContent = self._sanitizeResponse(self._getMessageFromLLMResponse(response))
                        fileName = f"{os.path.splitext(file)[0]}_title_body_AutoGenerated_{self._sanitizedModelName(model)}{os.path.splitext(file)[1]}"
                        fileName = self.fileManager.createFile(self.folderPath, fileName)
                        filePathOut = os.path.join(self.folderPath, fileName)
                        self.fileManager.saveToFile("", filePathOut)
                        self.fileManager.saveToFile(prContent, filePathOut)
                    else:
                        logging.error(f"Failed to generate PR title and body for {file} with model {model}.")
                else:
                    logging.info(f"File {file} already processed for model {model}. Skipping...")

        logging.info("Automated Pull Request Generator for all models completed successfully.")

    def generatePullRequestTitleAndDescription(self, filePath: str, model: str = 'llama3.1:8b') -> Optional[requests.Response]:
        """
        Generates a pull request title and body based on the provided file path.

        Args:
            filePath (str): The path to the file containing the code diff.

        Returns:
            Optional[requests.Response]: The API response object if successful, None otherwise.
        """
        try:
            response = self.openUiClient.chatWithModel(model, filePath=filePath)
            if response:
                logging.info(f"Generated PR title and body for {filePath}:\n {self._getMessageFromLLMResponse(response)}")
                return response
            else:
                logging.error(f"Failed to generate PR title and body for {filePath}.")
                return None
        except Exception as e:
            logging.error(f"Error generating PR title and body: {e}")
            return None
    
    def getPRsDiffFilesAndDescriptionSamplesAsMap(self) -> dict:
        """
        Maps diff files to their corresponding title and body files.

        Returns:
            dict: A dictionary where keys are diff file names and values are title and body file names.
        """
        logging.debug("Starting getPRsDiffFilesAndDescriptionSamplesAsMap method.")
        filesDownloaded = self.scanAllFilesInFolder()
        logging.info(f"Files downloaded: {len(filesDownloaded)}")
        fileMap = {}
        for file in filesDownloaded:
            logging.debug(f"Processing file: {file}")
            title_body_file = f"{os.path.splitext(file)[0]}_title_body{os.path.splitext(file)[1]}"
            if title_body_file in filesDownloaded:
                logging.debug(f"Matching title_body_file found: {title_body_file}")
                fileMap[file] = title_body_file
            else:
                logging.debug(f"No matching title_body_file found for: {file}")
        logging.info(f"Total files in map: {len(fileMap)}")
        return fileMap
    
    def scanAllFilesInFolder(self) -> list:
        """
        Scans all files in the specified folder.

        Returns:
            list: A list of file names in the folder.
        """
        folderPath = self.folderPath
        try:
            files = os.listdir(self.folderPath)
            return files
        except FileNotFoundError:
            logging.error(f"Folder not found: {folderPath}")
            return []
    
    def downloadPullRequestSamples(self) -> dict:
        """
        Fetches pull requests for all repositories and saves their file changes in separate .txt files.

        Returns:
            dict: A map with file names as keys and file paths as values.
        """
        files_in_folder = self.scanAllFilesInFolder()

        if files_in_folder:
            user_input = input(f"There are {len(files_in_folder)} files present in the folder. Type 'download' to proceed with downloading pull request samples: ").strip().lower()
            if user_input == 'download':
                logging.info("Starting to download pull request samples.")
                start_time = time.time()  # Start timing the operation

                urls = self.codeSamplesFetcher.fetchCodeSamplesHtmls()
                reposList = self.codeSamplesFetcher.fetchOwnsersAndReposFromUrls(urls)

                file_map = {}  # Map to store file names and their paths
                total_prs_downloaded = 0  # Counter for total pull requests downloaded

                for state in PullRequestState:
                    logging.info(f"Processing pull requests with state: {state.name}")
                    for repo in reposList:
                        owner = repo['owner']
                        repoName = repo['repo']
                        logging.info(f"Fetching pull requests for repository: {owner}/{repoName}")

                        try:
                            total_prs_downloaded += self._processRepository(owner, repoName, state, file_map)
                        except Exception as e:
                            logging.error(f"Error processing repository {owner}/{repoName}: {e}")
                            continue
                        time.sleep(0.2)  # Wait for 200 milliseconds to avoid hitting API rate limits

                end_time = time.time()  # End timing the operation
                total_time = end_time - start_time
                logging.info(f"Finished downloading pull request samples. Total pull requests downloaded: {total_prs_downloaded}")
                logging.info(f"Total time taken: {total_time:.2f} seconds")
                return file_map
            else:
                logging.info("User chose not to download pull request samples.")
                return {}  
    
    def _sanitizedModelName(self, model: str) -> str:
        # Sanitize the model name to replace invalid characters
        return model.replace(":", "_").replace(" ", "_").strip()
    
    def _sanitizeResponse(self, response: str) -> str:
        """
        Removes the first introduction line (if it does not contain 'Title:') and markdown formatting from the LLM response.

        Args:
            response (str): The raw response string from the LLM.

        Returns:
            str: The cleaned response string.
        """
        lines = response.splitlines()
        if lines and 'Title:' not in lines[0]:
            lines = lines[1:]
            # Remove empty line after intro if present
            if lines and lines[0].strip() == "":
                lines = lines[1:]
        # Remove markdown bold formatting (**)
        cleaned = "\n".join(lines).replace("**", "")
        return cleaned.strip()
    def _getMessageFromLLMResponse(self, response: requests.Response) -> str:
        """
        Extracts the message content from the LLM API response.

        Args:
            response (requests.Response): The API response object.

        Returns:
            str: The extracted message content.
        """
        return response.json()['choices'][0]['message']['content']
    
    def _processRepository(self, owner: str, repoName: str, state: PullRequestState, file_map: dict) -> int:
        """
        Processes a single repository to fetch pull requests and save their file changes.

        Args:
            owner (str): The owner of the repository.
            repoName (str): The name of the repository.
            state (PullRequestState): The state of the pull requests to fetch.
            file_map (dict): A map to store file names and their paths.

        Returns:
            int: The number of pull requests processed.
        """
        pullRequests = self.gitHubClient.getPulls(owner, repoName, state)
        total_prs_downloaded = 0

        for pr in pullRequests:
            prNumber = pr['number']
            fileName = f"{owner}_{repoName}_{prNumber}.txt"
            fileName = self.fileManager.createFile(self.folderPath, fileName)

            filePath = os.path.join(self.folderPath, fileName)
            file_map[fileName] = filePath  # Store file name and path in the map

            logging.info(f"Saving pull request #{prNumber} to file: {fileName}")
            self.fileManager.saveToFile("", filePath)

            fileChanges = self.gitHubClient.getFilesChangedInPR(owner, repoName, prNumber)
            concatenated_files = self._formatFileChanges(fileChanges)

            self.fileManager.appendToFile(concatenated_files, filePath)
            logging.info(f"Pull request #{prNumber} saved successfully.")

            # Save PR title and body
            self._savePRTitleAndBody(owner, repoName, pr)

            total_prs_downloaded += 1  # Increment the counter

        return total_prs_downloaded

    def _savePRTitleAndBody(self, owner: str, repoName: str, pr: dict) -> None:
        """
        Saves the title and body of a pull request to a separate file.

        Args:
            owner (str): The owner of the repository.
            repoName (str): The name of the repository.
            pr (dict): The pull request data.
        """
        prNumber = pr['number']
        title = pr.get('title', 'No title available')
        body = self.gitHubClient.convertBodyToString(pr.get('body', ''))

        fileName = f"{owner}_{repoName}_{prNumber}_title_body.txt"
        fileName = self.fileManager.createFile(self.folderPath, fileName)
        filePath = os.path.join(self.folderPath, fileName)

        content = f"Title: {title}\n\nBody:\n{self.gitHubClient.convertBodyToString(body)}"
        self.fileManager.saveToFile(content, filePath)

        logging.info(f"Pull request title and body saved to file: {fileName}")

    def _formatFileChanges(self, fileChanges: list) -> str:
        """
        Formats the file changes into a concatenated string.

        Args:
            fileChanges (list): A list of file change dictionaries.

        Returns:
            str: A formatted string representing the file changes.
        """
        return "\n".join(
            f"File: {file['filename']}, Status: {file['status']}, Content: {file.get('patch', 'No content available')}"
            for file in fileChanges
        )
